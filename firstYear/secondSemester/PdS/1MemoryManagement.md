# 1 - Memory management

## Background
Usually, a program is on disk as a binary executable file. When  we have to run the program, it is transfered from disk to main memory, within a process, to be eligible for execution of the CPU. 

(As we know, CPU has direct access to main memory and registers, so it's very important to transfer the code from memory to more accessable point for the CPU)

## Problems related to management of memory
In this phase, there are problems related to:
- Space, how much data has to be transfered;
- Speed of loading and storing data;
- Dealing with a lot of processes, each of them with theri data and information that has to be managed indipendently.

## Protection
Another important property is protection, which ensure a process to access only to addresses within its address space and to prevent illegal operation. 

Protection of process's address space is perfomed by using registers called: 
- **base**, which specifies the smallest legal physical memory address;
- **limit** specifies the size of the range. Added to base value, it identifies the biggest legal physical memory address.

In particular cases (see later run time binding), the computations of the address legacy of a certain process is performed by a unit of the CPU, the **Memory Management Unit**, that is an hardware module that guarantee speed. 

<add image slide 8 and 7>


## Address  binding
The addresses in the source code are generally _symbolic_, so the compiler tipically binds these addresses to _relocatable_ addresses.
The address binding is the process of assigning (mapping) a memory address to a program (or a process) at the time of execution. 

### Stages of running programs
Running software programs implies three stages:
- compile time, when the source code of a program is convertedn into machine code;
- load time, when the machine code is loaded into memory (disk);
- Run time, when the code is transfered from disk to main memory and the program is executed.

Address binding can be perfomed in any of the stages, producing different results:
- at compile time, the source code already refers to physical address, so the binding generates _absolute code_. This implies that by changing some allocation in the code, all the other address must be changed;
- at load time, the compiler generates the relocatable code. When this code is loaded into memory, the binding od physical memory is performed.
- at execution time, binsing is performed only when the CPU is available to execute code. By this time, all the assignments are made.

## Definitions of addresses and properties
- **Logical address** (or virtual address) is generated by the CPU;
- **Physical address** is address seen by memory unit. 

Performing binding at compile or load time implies that physical and logical address is the same, while at execution time, binding results in different spaces:
- Logical address space contains all the logical address generated by a program;
- Physical address space contains all the physical ones.
The run-time mapping is made by the MMU.

### Memory Management Unit
The base register is renamed as **relocation register** and its value is added to every address generated by a process when it is sent to memory (physical)

<add image slide 15>

## Loading data of a program
when program code is loaded into memory, how much data has to be transfered? 
We know the entire program must be in memory in order to be executed. So, the **dynamic loading** loads all the libraries or modules into memory at run time, with the intention of load only necessary components when needed (efficiency) and speed up program (by reduce memory allocation).

We distinguish two types of linking:
- static linking, that combine libraries and program code into the binary program image;
- dynamic linked libraries (DLL) that link libraries to user program when they have to be executed. The advantages are shared resources, enhance modularity and reduce memory usage.



